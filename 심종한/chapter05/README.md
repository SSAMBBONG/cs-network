# 5️⃣ Chapter 05: 응용 계층

# 5-1 DNS와 지원

### 도메인 네임과 네임 서버

IP주소를 기억하기 어렵기 때문에 도메인 네임을 사용하고 `DNS 서버`에서 도메인 네임을 관리한다.

도메인은 .을 기준으로 계층적으로 분류된다.

루트 도메인, 최상위 도메인, 2단계 도메인, 전체 주소 도메인 네임으로 구분할 수 있다..

- **루트 도메인**: .
- **최상위 도메인**: com
- **2단계 도메인**: example
- **3단계 도메인**: www
- **전체 주소 도메인**: 일반적으로 3 ~ 5단계 정도의 도메인으로 구성되며 전체 도메인 이름을 포함하고 `FQDN (Fully-Qualified Domain Name)` 이라고 부른다.

### 계층적 네임 서버

도메인 이름을 통해 IP 주소를 알아내는 과정에 다양한 네임 서버가 사용된다. 크게 4가지로 구분된다.

- **로컬 네임 서버**: 클라이언트가 가장 먼저 찾는 네임 서버
- **루트 네임 서버**: 최상위 도메인(ex. com)을 관리하는 TLD 네임 서버의 주소를 알려준다.
- **TLD(최상위 도메인) 네임 서버**: 하위 도메인 네임(ex. example.com)을 관리하는 네임 서버 주소를 반환한다.
- **책임 네임 서버**: 자신이 관리하는 도메인 영역의 질의에 대해서는 다른 네임 서버에게 떠넘기지 않고 답을 할 수 있는 네임서버다.

![alt text](../img/ch5-계층적네임서버.png)

도메인 네임을 리졸빙하는 과정에는 크게 2가지 방법이 있다.

#### [1] 재귀적 질의

![alt text](../img/ch5-재귀적질의.png)

#### [2] 반복적 질의

![alt text](../img/ch5-반복적질의.png)

그러나 이런 방법으로 도메인 리졸빙을 하면 시간이 오래 걸리고 네트워크상의 메시지 수가 많아질 수 있다. 또한 동시에 많은 질의가 루트 네임 서버로 요청되면 과부하가 발생할 수 있다. 이런 문제를 개선하고자 네임 서버들은 `DNS 캐시`를 사용한다.

### 자원을 식별하는 URI

네트워크 상에서 자원을 주고받으며 식별할 수 있어야 한다. 자원을 식별할 수 있는 정보를 `URI (Uniformed Resource Identifier)` 라고 한다.

URI는 자원의 위치를 이용한 식별 `URL`, 이름을 이용한 식별 `URN` 두 가지로 구분된다.

> [!NOTE]
>
> **DNS 레코드 타입**
>
> 네임 서버는 `DNS 자원 레코드`라 불리는 정보를 저장하고 관리한다.
>
> ![alt text](../img/ch5-DNS레코드타입.png)

# 5-2 HTTP

### HTTP의 특성

응용 계층에서 정보를 주고받는 데 사용되는 프로토콜이다. 4가지의 특성은 다음과 같다.

#### [1] 요청-응답 기반 프로토콜

#### [2] 미디어 독립적 프로토콜

HTTP는 자원의 특성을 제한하지 않는다. 자원가 상호 작용하는 데 사용할 수 있는 인터페이스를 정의하는 것이다. 그리고 대부분의 자원은 URI로 식별된다.

HTTP에서 메시지로 주고받는 자원의 종류를 `미디어 타입이(MIME 타입)` 라고 한다.
그리고 미디어 타입은 `타입/서브타입` 형식으로 구분된다.

![alt text](../img/ch5-미디어타입.png)

또한 타입에 대해 부가적인 설명을 위해 매개변수가 포함될 수 있다.

```
type/subtype;parameter=value
```

#### [3] 스테이트리스 프로토콜

서버는 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다. 따라서 모든 클라이언트의 HTTP 요청은 독립적인 요청으로 간주된다.

서버가 만약 클라이언트의 상태 정보를 유지한다면 서버에 부담이 될 수 있다.
서버가 여러 대로 구성된 경우, 모든 서버가 클라이언트 상태 정보를 공유하는 것이 힘들기 때문에 클라이언트가 여러 서버를 동시에 이용하기 어려워진다.

또한 특정 클라이언트가 특정 서버에 종속될 수 있다.
한 서버에 문제가 발생하면 해당 서버에 종속된 클라이언트는 직전까지의 HTTP 통신 내역을 잃어버리게 된다.

상태를 기억하지 않는 이유를 정리하면

1. 클라이언트 상태를 유지하면서 서버에 부담이 될 수 있음
2. 클라이언트가 서버에 종속될 수 있음

클라이언트의 상태를 기억하지 않기 때문에 HTTP는 `확장성` 과 `견고성` 을 높다.

#### [4] 지속 연결 프로토콜

기본적으로 HTTP는 TCP상에서 동작한다. 그러나 HTTP는 비연결형, TCP는 연결형 프로토콜이다.
그래서 초기 HTTP 1.0이하에서는 TCP 연결을 맺은 후 요청을 보내 응답을 받응 후 연결을 종료하는 식으로 동작했다.
이런 방식을 `비지속 연결`이라고 한다.

그러나 HTTP 1.1 이상은 keep-alive 기술을 제공하여 TCP 연결을 맺은 상태에서 여러 개의 요청, 응답을 주고받을 수 있게 되었다.

![alt text](../img/ch5-지속연결프로토콜.png)

### HTTP 메시지 구조

![alt text](../img/ch5-HTTP메시지구조.png)

요청 메시지인 경우 시작 라인은 `요청 라인`, 응답 메시지인 경우 시작 라인은 `상태 라인`이 된다.

- **요청 라인**: 메서드, 요청 대상, HTTP 버전으로 구성된다.

```
GET /example-page HTTP/1.1
```

- **상태 라인**: HTTP 버전, 상태 코드, 이유 구문으로 구성된다.

```
HTTP/1.1 200 OK

HTTP/1.1 404 NOT FOUND
```

### HTTP 메서드

![alt text](../img/ch5-HTTP메서드.png)

### HTTP 상태 코드

![alt text](../img/ch5-HTTP상태코드.png)

#### 200번대: 성공 상태 코드

![alt text](../img/ch5-200번대.png)

#### 300번대: 리다이렉션 상태 코드

- 영구적인 리다이렉션
  ![alt text](../img/ch5-영구적인리다이렉션.png)

- 일시적인 리다이렉션
  ![alt text](../img/ch5-일시적인리다이렉션.png)

#### 400번대: 클라이언트 에러 상태 코드

![alt text](../img/ch5-에러코드.png)

#### 500번대: 서버 에러 상태 코드

![alt text](../img/ch5-서버에러코드.png)

### HTTP의 발전: 0.9 ~ 3.0까지

1. **HTTP/0.9**

- GET 메서드만 사용 가능했다.
- 헤더가 지원되지 않았다.

2. **HTTP/1.0**

- HEAD, POST 같은 메서드가 도입됐다.
- 지속 연결을 지원하지 않아 연결 수립 과정이 매 요청마다 필요했다.

3. **HTTP/1.1**

- 지속 연결을 지원했다.
- 응답이 수신되기 전에 다음 요청을 보낼 수 있는 파이프라이닝 기능, 콘텐츠 협상 기능 등 여러 편의 기능이 추가됐다.

4. **HTTP/2.0**

- HTTP/1.0을 보완하고 개선한 버전이다.
- 헤더를 압축하여 전송하고 텍스트 기반이 아닌 바이너리 기반의 메시지를 송수신한다.
- 클라이언트가 미래에 필요할 것으로 예상되는 자원을 미리 전송해 주는 서버 푸시 기능을 제공한다.
- `HOL 블로킹 (Head-of-Line blocking)` 문제를 완화했다.
  ![alt text](../img/ch5-HOL블로킹.png)
- 멀티 플렉싱 기법을 도입하여 병렬적으로 메시지를 주고 받는 것이 가능해졌다. 따라서 요청과 응답을 주고받는 단위가 하나의 스트림에서 이루어지며 동시에 여러 스트림을 활용할 수 있게 되었다.

5. **HTTP/3.0**

- 이전 버전들과 다르게 UDP를 기반으로 동작한다.
- TCP에 비해 속도가 많이 개선되었다.

# 5-3 HTTP 헤더와 HTTP 기반 기술

필드 라인에는 다양한 HTTP 헤더들이 명시된다.

### HTTP 헤더

#### 요청 시 활용되는 HTTP 헤더

- **Host**: 요청을 보낼 호스트를 나타낸다.
- **User-Agent**: HTTP 요청을 시작하는 클라이언트 측의 프로그램을 의미한다.
- **Referer**: 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시된다. 클라이언트의 유입 경로를 파악할 수 있다.
- **Authorization**: 인증 타입과 인증을 위한 정보가 명시된다.
  ```
  Authorization: Basic adsfAFVmklajdfkl
  ```

#### 응답 시 활용되는 HTTP 헤더

- **Server**: 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시한다.
  ```
  Server: Apache/2.4.1 (Unix)
  ```
- **Allow**: 클라이언트에게 허용된 HTTP 메서드 목롱을 알려주기 위해 사용한다.
- **Retry-After**: 503 상태 코드와 함께 사용될 수 있다.
- **WWW-Authenticate**: 401 상태 코드와 함께 사용된다. 자원에 접근하기 위한 인증 방식을 설명하는 헤더다.
  ![alt text](../img/ch5-www-authenticate.png)

#### 요청과 응답 모두에서 활용되는 HTTP 헤더

- Date: 메시지가 생성된 날짜, 시간 정보를 담은 헤더다.
- Connection: 클라이언트의 요청과 응답 간 연결 방식을 설정하는 헤다다.
  ```
  Connection: keep-alive
  ```
- Content-Type, Content-Language, Content-Encoding: 전송하려는 메시지 본문의 표현 방식을 설명한다.
  ```
  Content-Type: text/html; charset=UTF-8
  ```

### 캐시

서버의 응답 사본을 저장하여 불필요한 대역폭 낭비와 응답 지연을 방지할 수 있다.

캐시는 웹 브라우저, 클라이언트와 서버 사이에 위치한 중간 서버에 저장될 수도 있다.
전자를 `개인 전용 캐시`, 후자를 `공용 캐시` 라고 한다.

캐시된 사본 데이터가 얼마나 최신 원본 데이터와 유사한지를 나타내는 정도를 `캐시 신선도` 라고 한다.
보통 캐시할 데이터의 유효 기간을 설정하는데, 설정 방법에는 2가지가 있다.

1. Expires 헤더
2. Cache-Control 헤더의 Max-Age

그리고 캐시된 데이터가 여전히 신선한지 검사하는 방법에 2가지가 있다.

1. 날짜를 기반으로 검색

- If-Modified-Since 헤더를 통해 특정 시점 이후로 원본 데이터에 변경이 있었는지 물을 수 있
  ![alt text](../img/ch5-신선도검사-날짜.png)

2. 엔티티 태그 기반으로 검색
   ![alt text](../img/ch5-신선도검사-엔티티태그.png)

### 쿠키

서버에서 생성되어 클라이언트 측에 저장되는 데이터로 스테이트리스한 HTTP 특성을 보완하기 위한 수단이다.

> [!NOTE]
>
> **세션 인증**
>
> 클라이언트가 매번 서버로 인증 정보를 보내고 번거롭게 인증 과정을 거치지 않는다.
> 보통 쿠키로 세션 아이디를 저장한다.
> 세션 아이디는 처음 클라이언트가 인증할 떄 전송한 정보를 서버 측에서 검증하고 세션을 생성하여 응답에 쿠키로 전달한다.
> 이후 클라이언트는 세션 값을 함께 서버로 보내게 되고 서버 측에서 유효한 세션 아이디인지 확인하는 방식으로 인증 절차가 이루어진다.

이때 응답 메시지의 `Set-Cookie 헤더` 와 요청 메시지의 `Cookie 헤더` 를 통해 전달된다.

![alt text](../img/ch5-쿠키헤더.png)

또한 쿠기는 사용 가능한 도메인이 정해져 있다. 이는 응답 메시지 속 `Set-Cookie 헤더` 의 `domain 속성` 으로 정해진다.

```
Set-Cookie: name=gildong domain=example.com
```

추가로 같은 도메인이더라도 경로별로 쿠키를 구분해서 사용할 수도 있다.

`www.example.com/lectures` 와 `www.example.com/books` 에서 사용하려는 쿠키가 다를 수 있다. 이 경우 path 속성으로 경로를 지정할 수 있다.

```
Set-Cookie: name=gildong path=/lectures
```

그러나 쿠키에도 한계점이 있는데 바로 쿠키 정보가 쉽게 노출, 조작될 수 있다는 것이다. 이를 보완하기 위해 `Secure` , `HttpOnly` 속성이 있다.

### 콘텐츠 협상과 표현

같은 URI에 대해 가장 적합한 자원의 형태를 제공하는 메커니즘을 의미한다.

예를 들어 클라이언트가 선호하는 언어가 한국어인 경우 `Accept-Language: ko` 를 헤더에 추가하여 서버에 요청하면 된다. 또한 HTML 문서 타입을 선호한다면 헤더에 `Accept: text/html` 을 추가하여 요청하면 된다.

중요한 점은 선호도에 우선순위를 부여할 수 있다. 콘텐츠 협상 관련 헤더에 Quality Value의 약자 `q` 값을 추가하면 된다.

![alt text](../img/ch5-콘텐츠협상.png)
